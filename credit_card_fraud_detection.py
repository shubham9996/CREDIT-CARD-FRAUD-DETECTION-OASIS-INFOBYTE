# -*- coding: utf-8 -*-
"""CREDIT CARD FRAUD DETECTION

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/#fileId=https%3A//storage.googleapis.com/kaggle-colab-exported-notebooks/credit-card-fraud-detection-bae4b009-8628-4238-8b3e-8a6d0ed7d3f4.ipynb%3FX-Goog-Algorithm%3DGOOG4-RSA-SHA256%26X-Goog-Credential%3Dgcp-kaggle-com%2540kaggle-161607.iam.gserviceaccount.com/20240403/auto/storage/goog4_request%26X-Goog-Date%3D20240403T144850Z%26X-Goog-Expires%3D259200%26X-Goog-SignedHeaders%3Dhost%26X-Goog-Signature%3Dc3bbf6d9966c16af18a6a0e59902376818dc7de4c133e4908ec78e43a17f3b254463a5cf062af7b9878985bcc0534a4efc779ef0e39b6d3e3b0340a62e98ed9f94c9433179864b83a5d718f5e3f8c757f0b4cdeefd548cc329f1774d07143804888634fe0e75c479bbb82ba1691ce47b1d77807f4cb60d7a5d9a8e6a38a3e08a67ff47ead63cdd1403db4d4687eb62f329f0062d2db16822569809c3a9b160b51037d2ed377ade04b4976d653c7d2320ef465ad2e80d1bbae2c6a06ac668a8420870caa68bbaeb48694173c2d6ee0dd25ce5baf3f05cae81ab17b5b281a7f6b314aed810186a6f111db807dc7365fceebeae76a50fd8a79abad349d024fb6e60
"""

# IMPORTANT: RUN THIS CELL IN ORDER TO IMPORT YOUR KAGGLE DATA SOURCES
# TO THE CORRECT LOCATION (/kaggle/input) IN YOUR NOTEBOOK,
# THEN FEEL FREE TO DELETE THIS CELL.
# NOTE: THIS NOTEBOOK ENVIRONMENT DIFFERS FROM KAGGLE'S PYTHON
# ENVIRONMENT SO THERE MAY BE MISSING LIBRARIES USED BY YOUR
# NOTEBOOK.

import os
import sys
from tempfile import NamedTemporaryFile
from urllib.request import urlopen
from urllib.parse import unquote, urlparse
from urllib.error import HTTPError
from zipfile import ZipFile
import tarfile
import shutil

CHUNK_SIZE = 40960
DATA_SOURCE_MAPPING = 'creditcardfraud:https%3A%2F%2Fstorage.googleapis.com%2Fkaggle-data-sets%2F310%2F23498%2Fbundle%2Farchive.zip%3FX-Goog-Algorithm%3DGOOG4-RSA-SHA256%26X-Goog-Credential%3Dgcp-kaggle-com%2540kaggle-161607.iam.gserviceaccount.com%252F20240403%252Fauto%252Fstorage%252Fgoog4_request%26X-Goog-Date%3D20240403T144850Z%26X-Goog-Expires%3D259200%26X-Goog-SignedHeaders%3Dhost%26X-Goog-Signature%3D59d2bb85ab4ea4d13bdfa124e79516caef12d562d65454806ff9340baa100e28646574df8e71abb6740aedba2ff73269adc97d512b86344cbc151715407f95afa9ead24fc221c8b0e9314698743514a2e12f1da9e6bbf73837c82674e39f6fcb533f570eaaa380a96b421f798b2e1a60d3db8fc956a8abcd97a630aaa2953efbc71fd903a94676f220a1e264c98006cd6154c4e89fcc6ed83a2d7c8c0f63e898037d671235f15cea2969198bc085e13927c91f19263dd1810f6e8c53ca8f3870a860f668e751763ae59a926360ebef38759edb45a5051d1abc022c32e6a7eb4e9b2482aa3e025ea9f6ad54d23ea8bb7000933e896bdc218d2c51790efafd4433'

KAGGLE_INPUT_PATH='/kaggle/input'
KAGGLE_WORKING_PATH='/kaggle/working'
KAGGLE_SYMLINK='kaggle'

!umount /kaggle/input/ 2> /dev/null
shutil.rmtree('/kaggle/input', ignore_errors=True)
os.makedirs(KAGGLE_INPUT_PATH, 0o777, exist_ok=True)
os.makedirs(KAGGLE_WORKING_PATH, 0o777, exist_ok=True)

try:
  os.symlink(KAGGLE_INPUT_PATH, os.path.join("..", 'input'), target_is_directory=True)
except FileExistsError:
  pass
try:
  os.symlink(KAGGLE_WORKING_PATH, os.path.join("..", 'working'), target_is_directory=True)
except FileExistsError:
  pass

for data_source_mapping in DATA_SOURCE_MAPPING.split(','):
    directory, download_url_encoded = data_source_mapping.split(':')
    download_url = unquote(download_url_encoded)
    filename = urlparse(download_url).path
    destination_path = os.path.join(KAGGLE_INPUT_PATH, directory)
    try:
        with urlopen(download_url) as fileres, NamedTemporaryFile() as tfile:
            total_length = fileres.headers['content-length']
            print(f'Downloading {directory}, {total_length} bytes compressed')
            dl = 0
            data = fileres.read(CHUNK_SIZE)
            while len(data) > 0:
                dl += len(data)
                tfile.write(data)
                done = int(50 * dl / int(total_length))
                sys.stdout.write(f"\r[{'=' * done}{' ' * (50-done)}] {dl} bytes downloaded")
                sys.stdout.flush()
                data = fileres.read(CHUNK_SIZE)
            if filename.endswith('.zip'):
              with ZipFile(tfile) as zfile:
                zfile.extractall(destination_path)
            else:
              with tarfile.open(tfile.name) as tarfile:
                tarfile.extractall(destination_path)
            print(f'\nDownloaded and uncompressed: {directory}')
    except HTTPError as e:
        print(f'Failed to load (likely expired) {download_url} to path {destination_path}')
        continue
    except OSError as e:
        print(f'Failed to load {download_url} to path {destination_path}')
        continue

print('Data source import complete.')

# Commented out IPython magic to ensure Python compatibility.
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.preprocessing import LabelEncoder
from sklearn.model_selection import train_test_split
from sklearn.linear_model import LogisticRegression
from sklearn.ensemble import  RandomForestClassifier
from sklearn.metrics import accuracy_score,recall_score,precision_score,f1_score
from imblearn.over_sampling import RandomOverSampler
# %matplotlib inline

import os
for dirname, _, filenames in os.walk('/kaggle/input'):
    for filename in filenames:
        print(os.path.join(dirname, filename))

df = pd.read_csv('/kaggle/input/creditcardfraud/creditcard.csv')

df.head()

df.shape

df.columns

df.info()

df.describe()

df.isna().sum()

df.isna().sum().sum()

df.drop_duplicates(inplace=True)

df.shape

fraudlent_transaction = df[df['Class'] == 1]
legimate_transaction = df[df['Class'] == 0]

fraudlent_transaction.shape

legimate_transaction.shape

"""Data visualization"""

plt.figure(figsize=(10,6))
sns.countplot(data=df,x='Class')
plt.title('Distribution of fraudlent against legimate transactions')
plt.xticks((1,0),labels=['fraudlent_transaction','legimate_transaction'])
plt.show()

sns.histplot(data=df,x='Time',kde=True)
plt.title('Distribuion of time')
plt.show()

plt.figure(figsize=(10,5))
sns.heatmap(data=df.corr(),annot=False,linewidths=0.5)

plt.show()

X = df.drop(columns='Class')
y = df['Class']

ros = RandomOverSampler(random_state=42)
X_resampled, y_resampled = ros.fit_resample(X, y)

X_train,X_test,y_train,y_test = train_test_split(X_resampled,y_resampled,test_size=0.3,random_state=42)

logreg = LogisticRegression()
logreg.fit(X_train,y_train)

y_pred_logreg = logreg.predict(X_test)

print(f"Accuaracy Score: {accuracy_score(y_test,y_pred_logreg)}")
print(f"Recall Score: {recall_score(y_test,y_pred_logreg)}")
print(f"Precission Score: {precision_score(y_test,y_pred_logreg)}")
print(f"F1 Score: {f1_score(y_test,y_pred_logreg)}")

rf_classifier = RandomForestClassifier()
rf_classifier.fit(X_train,y_train)

y_pred_rf_classifier = rf_classifier.predict(X_test)

print(f"Accuaracy Score: {accuracy_score(y_test,y_pred_rf_classifier)}")
print(f"Recall Score: {recall_score(y_test,y_pred_rf_classifier)}")
print(f"Precission Score: {precision_score(y_test,y_pred_rf_classifier)}")
print(f"F1 Score: {f1_score(y_test,y_pred_rf_classifier)}")